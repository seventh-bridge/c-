# 函数
## 局部静态对象
局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。
```
    size_t count_calls()
    {
        //调用结束后，这个值仍然有效
        static size_t ctr = 0;
        return ++ctr;
    }

    for (size_t i = 0; i != 10; ++i)
    {
        cout << count_calls() << endl;
    }
```
局部静态变量只有在第一次执行时赋予初值，之后都不会再进行赋初值的操作，生命周期会持续到程序结束而结束。
## 使用引用形参返回额外信息
一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。
```
    string ::size_type find_char(const string &s, char c, string::size_type &occurs)
    {
        //第一次出现的位置(如果有的话)
        auto ret = s.size();
        //设置表示出现次数的形参的值
        occurs = 0;
        for (decltype(ret) i = 0; i != s.size(); ++i)
        {
            if (s[i] == c)
            {
                if (ret == s.size())
                    //记录c第一次出现的位置
                    ret = i;

                //出现的次数+1
                ++occurs;
            }
        }
        return ret;
    }
```
## initializer_list形参
如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组
```
    void error_msg(initializer_list<string> il)
    {
        for (auto beg = il.begin(); beg != il.end(); beg++)
        {
            cout << *beg << " ";
        }
        cout << endl;
    }
```
## 使用decltype
如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：
```   
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    //返回一个指针，该指针指向含有5个整数的数组
    decltype(odd) *arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;
    }
```
## 函数重载
如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。编译器会根据所给定的形参类型，判断使用哪个函数。
## 函数指针
函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。
```
    // pf指向一个函数,该函数的参数是两个const string 的引用，该函数返回bool类型
    bool (*pf)(const string &, const string &);
```
## function与lambda
```cpp
function<int(int)> dfs = [&](int i) -> int {
    if (i <= 1) return 0;
    int &res = memo[i];
    if (res != -1) return res;
    return res = min(dfs(i - 1) + cost[i - 1], dfs(i - 2) + cost[i - 2]);
};
//[捕获列表](参数列表)->返回类型{函数体};
//function<int(int)>：声明了一个类型为 function<int(int)> 的变量 dfs。
//这里的 function<int(int)> 表示一个接受 int 类型参数并返回 int 类型结果的函数对象。
//[&](int i) -> int：这是 lambda 表达式的基本形式。
//[&] 表示捕获外部变量的引用，(int i) 是参数列表，-> int 指定了返回值类型。
// 此 lambda 表达式定义了一个函数，它接受一个 int i 参数，返回一个 int 类型的值。
```
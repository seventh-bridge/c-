# 多态
将派生类对象视为基类对象，并执行派生类的成员函数实现。
对于使用`new`在自由存储区中实例化的派生类对象，如果将其赋给基类指针，并通过该指针调用`delete`，将不会调用派生类的析构函数。
```cpp
    class Fish{
        public:
        Fish(){

        }
        ~Fish(){

        }
    }

    class Tuna{
        public:
        Tuna(){

        }
        ~Tuna(){

        }
    }

    void DeleteFishMemory(Fish* pFish){
        delete pFish;
    }

    int main(){
        Tuna* pTuna=new Tuna;
        DeleteFishMemory(pTuna);//只调用了Fish的析构函数

        Tuna myTuna;//程序结束时，先调用Tuna的析构函数，再调用Fish的析构函数

        return 0;
    }
```
将基类的析构函数声明为虚函数，确保通过基类指针调用`delete`时，也会调用派生类的析构函数。
```cpp
    class Fish{
        public:
        Fish(){

        }
        virtual ~Fish(){

        }
    }

    class Tuna{
        public:
        Tuna(){

        }
        ~Tuna(){

        }
    }

    void DeleteFishMemory(Fish* pFish){
        delete pFish;
    }

    int main(){
        Tuna* pTuna=new Tuna;
        DeleteFishMemory(pTuna);//先调用Tun的析构函数，再调用Fish的析构函数

        Tuna myTuna;//程序结束时，先调用Tuna的析构函数，再调用Fish的析构函数

        return 0;
    }
```
## 关键字`virtual`
在函数声明中，`virtual`表示当基类指针指向派生类对象时，通过它可调用派生类的相应函数。而在类继承声明中使用了`virtual`，例如从`Base`类中派生出`Derived1`和`Derived2`，则表示再从`Derived1`和`Derived2`派生出`Derived3`时，`Derived3`实例中只包含一个`Base`实例。
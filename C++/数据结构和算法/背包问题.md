# 背包问题
## 0-1背包 
问题描述：有n个物品，第i个物品的体积为w[i]，价值为v[i]，每个物品至多选一个，求体积和不超过capacity时的最大价值和。
思路过程：
1. 当前操作：第i个物品选或不选，不选则剩余容量不变，选则剩余容量减少w[i]。
2. 延伸子问题：在剩余容量为c时，从前i个物品中得到的最大价值和。
3. 不选，在剩余容量为c时，从前i-1个物品中得到的最大价值和；选，在剩余容量为c-w[i]时，从前i-1个物品中得到的最大价值和。
```cpp
dfs(i,c)=max(dfs(i-1,c),dfs(i-1,c-w[i])+v[i]);
```
转为递推形式：
```cpp
f[i+1][c]=max(f[i][c],f[i][c-w[i]]+v[i]);//考虑下标问题，所以需要加1

//空间优化，可以只用两个数组
f[(i+1)%2][c]=max(f[i%2][c],f[i%2][c-w[i]]+v[i]);
```
## 完全背包
问题描述：有n种物品，第i种物品的体积为w[i]，价值为v[i]，每个物品无限次重复选，求体积和不超过capacity时的最大价值和。
思路过程：
1. 当前操作：第i种物品选或不选，不选则剩余容量不变，选则剩余容量减少w[i]。
2. 延伸子问题：在剩余容量为c时，从前i种物品中得到的最大价值和。
3. 不选，在剩余容量为c时，从前i-1种物品中得到的最大价值和；选，在剩余容量为c-w[i]时，从前i种物品中得到的最大价值和。
```cpp
dfs(i,c)=max(dfs(i-1,c),dfs(i,c-w[i])+v[i]);
```
转为递推形式：
```cpp
f[i+1][c]=max(f[i][c],f[i+1][c-w[i]]+v[i]);//考虑下标问题，所以需要加1

//空间优化，可以只用两个数组
f[(i+1)%2][c]=max(f[i%2][c],f[(i+1)%2][c-w[i]]+v[i]);
```
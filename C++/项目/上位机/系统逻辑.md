# 工程z完整程序逻辑详解

## 1. 程序启动流程

### 1.1 应用程序入口
```cpp
// main.cpp
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);           // 创建Qt应用程序实例
    MainWindow window;                      // 创建主窗口
    window.show();                          // 显示主窗口
    return app.exec();                      // 启动事件循环
}
```

### 1.2 主窗口初始化
当MainWindow构造函数被调用时，执行以下初始化步骤：

1. **核心模块创建**
   - 创建UdpTransport网络传输模块
   - 创建ProtocolHandler协议处理模块
   - 创建FileManager文件管理模块
   - 创建Logger日志记录模块

2. **界面初始化**
   - 调用`setupUI()`设置界面控件状态
   - 设置默认保存路径为用户文档目录
   - 初始化进度条为隐藏状态

3. **信号连接**
   - 连接所有按钮的点击信号到对应槽函数
   - 连接UDP数据接收信号
   - 连接文件操作完成信号

4. **后台服务启动**
   - 启动日志更新定时器（每100ms更新一次）

## 2. 程序核心工作模式

### 2.1 双向通信模式
工程z支持两种工作模式：
- **发送端模式**: 选择文件并发送到目标地址
- **接收端模式**: 监听指定端口接收文件数据

### 2.2 异步处理机制
- 网络通信采用异步非阻塞方式
- 文件操作使用QtConcurrent进行异步处理
- UI更新通过定时器机制避免阻塞

## 3. 文件发送逻辑详解

### 3.1 发送流程触发
用户点击"发送文件"按钮 → 调用`onSendFile()`函数

### 3.2 详细发送步骤

```
1. 用户操作
   ↓
2. 弹出文件选择对话框
   ↓
3. 用户选择要发送的文件
   ↓
4. FileManager加载文件到内存
   ↓
5. 获取文件基本信息（文件名、大小）
   ↓
6. 验证目标IP和端口有效性
   ↓
7. 设置远程端点信息到UdpTransport
   ↓
8. FileManager将文件按1400字节分片
   ↓
9. ProtocolHandler为每个分片创建数据包
   ↓
10. 通过UdpTransport依次发送数据包
    ↓
11. 显示发送进度（进度条更新）
    ↓
12. 发送完成后记录日志
```

### 3.3 数据包发送过程
```cpp
// 每个分片的处理流程
for (每个文件分片) {
    1. ProtocolHandler::createDataPacket()创建数据包
       - 添加包头（魔数、序列号、长度）
       - 计算并添加CRC32校验码
       - 添加包尾标识
    2. UdpTransport::sendDatagram()发送数据包
       - 使用QUdpSocket发送到目标地址
}
```

## 4. 文件接收逻辑详解

### 4.1 接收流程触发
用户点击"开始监听"按钮 → 调用`onStartListening()`函数

### 4.2 详细接收步骤

```
1. 用户设置监听端口并开始监听
   ↓
2. UdpTransport启动UDP监听服务
   ↓
3. 等待接收UDP数据包
   ↓
4. 接收到数据包时触发onDataReceived()
   ↓
5. ProtocolHandler验证数据包完整性
   ↓
6. 提取数据包中的文件数据和序列号
   ↓
7. 按序列号存储接收到的数据
   ↓
8. 更新接收进度显示
   ↓
9. 检查文件是否完整接收
   ↓
10. 完整接收后触发自动保存或等待手动保存
```

### 4.3 数据包接收处理
```cpp
void MainWindow::onDataReceived(const QByteArray& data, const QHostAddress& sender, quint16 senderPort)
{
    // 1. 数据包验证
    if (protocol_handler_->validatePacket(data)) {
        // 2. 提取数据包信息
        auto result = protocol_handler_->extractPacketData(data);
        quint32 sequence = result.first;      // 序列号
        QByteArray packet_data = result.second; // 文件数据
        
        // 3. 存储接收到的数据包
        protocol_handler_->addReceivedPacket(sequence, packet_data);
        
        // 4. 更新进度显示
        double progress = protocol_handler_->getTransferProgress();
        ui_->progressBar->setValue(static_cast<int>(progress));
        
        // 5. 检查文件是否完整
        if (protocol_handler_->isFileComplete()) {
            // 6. 自动保存文件
            autoSaveReceivedFile();
        }
    } else {
        // 记录无效数据包日志
        logMessage("Received invalid packet", 2);
    }
}
```

## 5. 协议处理逻辑

### 5.1 数据包结构
```
┌─────────────┬──────────┬──────────┬────────────┬──────────┬────────────┐
│ 包头(24字节)│ 序号(4)  │ 长度(4)  │ 校验码(4)  │ 数据(N)  │ 包尾(4)    │
└─────────────┴──────────┴──────────┴────────────┴──────────┴────────────┘
```

### 5.2 数据包创建流程
```cpp
QByteArray ProtocolHandler::createDataPacket(quint32 sequence, const QByteArray& data)
{
    1. 构造包头信息
       - 设置魔数标识
       - 设置序列号
       - 设置数据长度
       - 校验码暂时设为0
    
    2. 计算校验码
       - 构造临时数据（包头+数据）
       - 使用CRC32算法计算校验码
    
    3. 构造完整数据包
       - 写入完整包头（包含校验码）
       - 写入文件数据
       - 写入包尾标识
    
    4. 返回构造好的数据包
}
```

### 5.3 数据包验证流程
```cpp
bool ProtocolHandler::validatePacket(const QByteArray& packet)
{
    1. 检查包长度是否足够
    2. 提取包头信息
    3. 验证魔数标识
    4. 验证包长度一致性
    5. 验证CRC32校验码
       - 临时将校验码设为0
       - 重新计算校验码
       - 与接收到的校验码比较
    6. 验证包尾标识
    7. 所有验证通过返回true
}
```

## 6. 文件管理逻辑

### 6.1 文件分片处理
```cpp
QList<QByteArray> FileManager::splitFile(int chunk_size)
{
    1. 检查文件数据是否为空
    2. 按指定大小（默认1400字节）循环分片
    3. 每次取chunk_size大小的数据
    4. 最后一片可能小于chunk_size
    5. 将所有分片存入QList返回
}
```

### 6.2 文件组装处理
```cpp
QByteArray ProtocolHandler::getCompleteFile()
{
    1. 获取所有接收到的数据包键值（序列号）
    2. 按序列号排序
    3. 按顺序将数据包内容拼接
    4. 调整最终大小为原始文件大小
    5. 返回完整文件数据
}
```

## 7. 自动保存机制

### 7.1 自动保存触发条件
- 文件接收完整（通过`isFileComplete()`判断）
- 已设置有效的保存路径

### 7.2 自动保存流程
```cpp
void MainWindow::autoSaveReceivedFile()
{
    1. 验证保存路径有效性
    2. 获取原始文件名
    3. 构造完整保存路径
    4. 处理文件名冲突
       - 如果文件已存在，添加序号后缀
    5. 从ProtocolHandler获取完整文件数据
    6. 使用FileManager保存文件
    7. 保存成功后重置协议处理器
    8. 更新界面状态
    9. 记录操作日志
}
```

## 8. 用户交互逻辑

### 8.1 界面状态管理
```cpp
void MainWindow::updateUIState()
{
    bool is_listening = udp_transport_->isListening();
    
    // 根据监听状态控制按钮可用性
    ui_->startButton->setEnabled(!is_listening);  // 未监听时可开始
    ui_->stopButton->setEnabled(is_listening);    // 监听时可停止
    ui_->sendButton->setEnabled(is_listening);    // 监听时可发送
    
    // 根据文件接收状态控制保存按钮
    ui_->saveButton->setEnabled(protocol_handler_->isFileComplete());
    
    // 网络配置控件状态控制
    bool can_configure = !is_listening;
    ui_->targetIpEdit->setEnabled(can_configure);
    ui_->targetPortEdit->setEnabled(can_configure);
    ui_->localPortEdit->setEnabled(can_configure);
}
```

### 8.2 进度显示管理
- 发送时实时更新进度条
- 接收时实时更新进度条
- 完成后隐藏进度条
- 错误时显示相应提示

## 9. 错误处理机制

### 9.1 网络错误处理
- 数据包校验失败记录日志
- 网络连接异常自动恢复
- 无效端口输入提示用户

### 9.2 文件操作错误处理
- 文件读取失败显示错误对话框
- 文件保存失败记录日志
- 磁盘空间不足检测

### 9.3 用户操作错误处理
- 无效输入验证和提示
- 操作冲突检测（如重复监听）
- 异常操作的友好提示

## 10. 日志系统逻辑

### 10.1 异步日志记录
```cpp
void MainWindow::logMessage(const QString& message, int level)
{
    1. 根据日志级别添加标签（DEBUG/INFO/WARNING/ERROR）
    2. 添加时间戳
    3. 将日志消息加入待显示队列
}

void MainWindow::updateLogDisplay()
{
    1. 定时器每100ms触发
    2. 从待显示队列取出所有日志消息
    3. 格式化日志内容
    4. 更新日志显示区域
    5. 自动滚动到最新日志
}
```

## 11. 程序生命周期管理

### 11.1 正常运行周期
```
启动 → 界面初始化 → 用户操作 → 功能执行 → 结果反馈 → 继续操作/退出
```

### 11.2 资源清理
```cpp
MainWindow::~MainWindow()
{
    1. 停止UDP监听服务
    2. 清理定时器资源
    3. 释放各模块资源
    4. 关闭日志文件
}
```

## 12. 数据流向图

```
发送端数据流向:
文件 → FileManager(加载/分片) → ProtocolHandler(打包) → UdpTransport(发送) → 网络

接收端数据流向:
网络 → UdpTransport(接收) → ProtocolHandler(解包/验证) → MainWindow(存储/组装) 
     → FileManager(保存) → 文件系统
```

## 13. 并发处理机制

### 13.1 异步网络处理
- 使用Qt的信号槽机制实现异步网络通信
- QUdpSocket的异步读写避免阻塞UI线程

### 13.2 异步文件操作
- 使用QtConcurrent进行文件读写操作
- 避免大文件操作阻塞界面

### 13.3 异步日志更新
- 日志记录与显示分离
- 定时器机制更新界面显示

整个程序采用模块化设计，各模块职责明确，通过Qt的信号槽机制实现松耦合通信，确保了程序的稳定性、可维护性和扩展性。
# 日志系统
## Log4J
    Logger（定义日志类别）
        |
        |------Formatter（日志格式）
        |
    Appender（日志输出地方）

## 1.日志管理
日志管理=日志器+日志级别+日志事件：
1. 日志器：定义`Logger`来统一管理日志。
2. 日志级别：定义`LogLevel`来统一管理日志级别。
3. 日志事件：
3.1 日志系统就是输出指定信息来观察程序的运行状态，因此需要输出两类信息，即辅助信息和业务信息。
3.2 辅助信息：时间 、线程id、线程名称、协程id、[日志级别]、[日志名称]、文件名:行号、换行符号；业务信息：消息。
3.3 定义日志事件`LogEvent`来统一管理信息。
```cpp
    #include <iostream>
    #include <string>   //日志名称用到了字符串
    #include <memory>   //智能指针所需的头文件
    #include <stdint.h>

    //定义日志级别
    class LogLevel{
    public:
        enum Level{
            UNKNOW = 0, //起手先来个未知级别兜底
            DEBUG = 1,  //调试级别
            INFO = 2,   //普通信息级别
            WARN = 3,   //警告信息
            ERROR = 4,  //错误信息
            FATAL = 5   //灾难级信息
        };
    };
    //定义日志事件，提供构造函数和获取信息（private中变量）函数
    class LogEvent {
    public:
        typedef std::shared_ptr<LogEvent> ptr;
        LogEvent(LogLevel::Level level
                ,const char* file, int32_t m_line, uint32_t elapse
                , uint32_t thread_id, uint32_t fiber_id, uint64_t time);

        const char* getFile() const { return m_file;}
        int32_t getLine() const { return m_line;}
        uint32_t getElapse() const { return m_elapse;}
        uint32_t getThreadId() const { return m_threadId;}
        uint32_t getFiberId() const { return m_fiberId;}
        uint64_t getTime() const { return m_time;}
        LogLevel::Level getLevel() const { return m_level;}
    private:
        LogLevel::Level m_level;       //日志级别           
        const char* m_file = nullptr;  //文件名
        int32_t m_line = 0;            //行号
        uint32_t m_elapse = 0;         //程序启动开始到现在的毫秒数
        uint32_t m_threadId = 0;       //线程id
        uint32_t m_fiberId = 0;        //协程id
        uint64_t m_time = 0;           //时间戳
    };

    //这里要注意，最好参数列表顺序和私有字段顺序对应，有些版本的编译器需要这样规定
    LogEvent::LogEvent(LogLevel::Level level
                ,const char* file, int32_t line, uint32_t elapse
                , uint32_t thread_id, uint32_t fiber_id, uint64_t time)
        :m_level(level)
        ,m_file(file)
        ,m_line(line)
        ,m_elapse(elapse)
        ,m_threadId(thread_id)
        ,m_fiberId(fiber_id)
        ,m_time(time){
    }

    //定义日志器，统一调用日志级别和事件
    class Logger{
    public:
        //定义智能指针
        typedef std::shared_ptr<Logger> ptr;
        //日志名称有且仅有构造时可以指定，如果未指定则给个默认名称 root 
        //这里传引用类型是为了避免不必要的拷贝操作
        //使用const是为了规定这个名称在内部不再会被改变
        Logger(const std::string& name = "root");
        
        //希望名称能被获取 但不应该被改变所以用const 为避免无用的拷贝所以返回引用类型
        const std::string& getName() const { return m_name; }
        LogLevel::Level getLevel() const { return m_level; }
        void setLevel(LogLevel::Level val) {m_level = val;}
        
        //定义了一个输出日志的方法 传入想要查看的最大日志级别
        void log(LogEvent::ptr event);
    private:
        //这里使用 m_ 开头是一个私有变量的规范
        std::string m_name;
        //日志器能输出的最大日志级别
        LogLevel::Level m_level;
    };

    //头文件中已经有默认值定义了 这里就不需要了(也就是不需要 nmae="root")，否则编译器会报错
    Logger::Logger(const std::string& name)
        :m_name(name)
        //这里指定日志器一个自身默认级别是DEBUG
        ,m_level(LogLevel::DEBUG){
    }
    void Logger::log(LogEvent::ptr event){
        //如果想要查看的级别大于等于当前日志器能查看的级别，那么才进行输出
        if(event->getLevel() >= m_level){
            std::cout << "日志输出模拟" << std::endl; 
        }
    }

    //此时我们可以写一个测试类试试
    int main(int argc,char** argv){
        //创建一个日志事件(这里的内容随便定义，因为我们没有真正用到它)
        LogEvent::ptr event(new LogEvent(LogLevel::WARN,0, 1, 2, 3,4, time(0)));
        Logger::ptr lg(new Logger("XYZ"));
        //由于默认是DEBUG级别 WARN>DEBUG 所以这里会输出
        lg->log(event); //日志输出模拟
        //将日志器级别改为ERROR
        lg->setLevel(LogLevel::ERROR);
        //此时 WARN<ERROR 所以不会输出任何信息
        lg->log(event);
        return 0;
    }
```
## 2.适配器基类
基于日志系统不仅需要将日志输出到控制台，还需要输出到本地磁盘、远程日志服务器等，起码需要有两种类型的适配器来承接对应业务。
由于多个适配器类在`Logger`类的`log`方法内部调用，因此可以在`Logger`中增加列表容器来保存多个`LogAppender`，并且提供新增和删除的方法。
1. `LogAppender`作为基类来实现多态。
```cpp
    class LogAppender{
    public:
        //定义智能指针
        typedef std::shared_ptr<LogAppender> ptr;
        //虚析构 空函数没有复杂逻辑所以 直接定义掉
        virtual ~LogAppender(){}
        //输出函数为纯虚函数，因为具体实现各个子类不一样，由各个子类自己决定
        virtual void log(LogEvent::ptr event) = 0;
    };
```
2. `StdoutLogAppender`负责打印日志到控制台。
```cpp
    //输出到控制台的Appender
    class StdoutLogAppender : public LogAppender {
    public:
        typedef std::shared_ptr<StdoutLogAppender> ptr;
        //这里的override用于表示是重写父类方法的
        void log(LogEvent::ptr event) override;
    };

    void StdoutLogAppender::log(LogEvent::ptr event){
        std::cout << "输出到控制台" << std::endl;
    }
```
3. `FileLogAppender`负责打印到本地磁盘文件。
```cpp
    //定义输出到文件的Appender
    class FileLogAppender : public LogAppender {
    public:
        typedef std::shared_ptr<FileLogAppender> ptr;
        FileLogAppender(const std::string& filename);
        void log(LogEvent::ptr event) override;
    private:
        std::string m_filename;
    };

    FileLogAppender::FileLogAppender(const std::string& filename)
        :m_filename(filename) {
    
    }

    void FileLogAppender::log(LogEvent::ptr event) {
    std::cout << "输出到文件：" << m_filename << std::endl;
    }
```
4. `Logger`中的改动
```cpp
    class Logger{
    public:
        //定义智能指针
        typedef std::shared_ptr<Logger> ptr;
        //日志名称有且仅有构造时可以指定，如果未指定则给个默认名称 root 
        //这里传引用类型是为了避免不必要的拷贝操作
        //使用const是为了规定这个名称在内部不再会被改变
        Logger(const std::string& name = "root");
        
        //希望名称能被获取 但不应该被改变所以用const 为避免无用的拷贝所以返回引用类型
        const std::string& getName() const { return m_name; }
        LogLevel::Level getLevel() const { return m_level; }
        void setLevel(LogLevel::Level val) {m_level = val;}
        
        //定义了一个输出日志的方法 传入想要查看的最大日志级别
        void log(LogEvent::ptr event);
        //新增一个适配器
        void addAppender(LogAppender::ptr appender);  
        //删除一个适配器  
        void delAppender(LogAppender::ptr appender);
    private:
        //这里使用 m_ 开头是一个私有变量的规范
        std::string m_name;
        //日志器能输出的最大日志级别
        LogLevel::Level m_level;
        //Appender集合
        std::list<LogAppender::ptr> m_appenders;
    };

    //头文件中已经有默认值定义了 这里就不需要了(也就是不需要 nmae="root")，否则编译器会报错
    Logger::Logger(const std::string& name)
        :m_name(name)
        //这里指定日志器一个自身默认级别是DEBUG
        ,m_level(LogLevel::DEBUG){
    }
    void Logger::addAppender(LogAppender::ptr appender) {
        m_appenders.push_back(appender);
    }

    void Logger::delAppender(LogAppender::ptr appender) {
        for(auto it = m_appenders.begin();
                it != m_appenders.end(); ++it) {
            if(*it == appender) {
                m_appenders.erase(it);
                break;
            }
        }
    }
    void Logger::log(LogEvent::ptr event){
        //如果想要查看的级别大于等于当前日志器能查看的级别，那么才进行输出
        if(event->getLevel() >= m_level){
            for(auto& i : m_appenders) {
                i->log(event);
            }
        }
    }
```
## 3.日志的输出信息可读化
1. 日志级别信息输出
```cpp
    //改造LogLevel::ToString，然后在相应的输出方法中调用即可
    class LogLevel{
    public:
        enum Level{
            UNKNOW = 0, //起手先来个未知级别兜底
            DEBUG = 1,  //调试级别
            INFO = 2,   //普通信息级别
            WARN = 3,   //警告信息
            ERROR = 4,  //错误信息
            FATAL = 5   //灾难级信息
        };

        static const char* ToString(LogLevel::Level level);
    };
    const char* LogLevel::ToString(LogLevel::Level level){
        switch(level) {
    #define XX(name) \
        case LogLevel::name: \
            return #name; \
            break;
            
        XX(DEBUG);
        XX(INFO);
        XX(WARN);
        XX(ERROR);
        XX(FATAL);
        
    #undef XX
        default:
            return "UNKNOW";
        }
        return "UNKNOW";
    }
```
2. 时间输出
```cpp
    void StdoutLogAppender::log(LogEvent::ptr event){
        //格式化时间
        const std::string format = "%Y-%m-%d %H:%M:%S";
        struct tm tm;
        time_t t = event->getTime();
        localtime_r(&t, &tm);
        char tm_buf[64];
        strftime(tm_buf, sizeof(tm_buf), format.c_str(), &tm);   
        
        std::cout
            //<< event->getTime() << "    "
            << tm_buf << "    "
            << event->getThreadId() << "    "
            << event->getFiberId() << "    "
            << "["
            << LogLevel::ToString(event->getLevel())
            << "]    "
            << event->getFile() << ":" << event->getLine() << "    "
            << "输出到控制台的信息"
            << std::endl;
    }
```
3. 文件名称和行号自动获取，`__FILE__`表示当前源文件名，类型为字符串常量，`__LINE__`代表当前程序行的行号，类型为十进制整数常量。
4. 线程和协程ID自动获取，`syscall(SYS_gettid)`表示获取当前线程ID，协程ID先忽略。
5. 每行输出内容的格式和顺序可由参数指定，实现自定义格式和格式解析。
定义`LogFormatter`类来处理，主要需要两个方法，一是初始化方法`init()`，将私有模板字符串解析，二是格式化方法`format()`，传入日志事件，返回格式化后的字符串。
```cpp
    class LogFormatter{
    public:
        typedef std::shared_ptr<LogFormatter> ptr;
        LogFormatter(const std::string& pattern);
        
        void init();
        //两种格式化的接收方法
        std::string format(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event);
        std::ostream& format(std::ostream& ofs, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event);

        class FormatItem {
            public:
                typedef std::shared_ptr<FormatItem> ptr;
                //有子类 需要虚析构
                virtual ~FormatItem() {}
                virtual void format(std::ostream& os, LogEvent::ptr event) = 0;
            };
    private:
        /// 日志格式模板
        std::string m_pattern;
        /// 日志格式解析后格式
        std::vector<FormatItem::ptr> m_items;
    };

    LogFormatter::LogFormatter(const std::string& pattern)
        :m_pattern(pattern){
        //在初始化时就将pattern解析好
        init();
    }
    //我们需要将模板字符串解析成 符号：子串：解析方式 的结构
    //例如这个模板 "%d{%Y-%m-%d %H:%M:%S}%T%t%T%F%T[%p]%T[%c]%T%f:%l%T%m%n"
    //可以解析成
    //符号    子串                   解析方式  注释
    //"d"    "%Y-%m-%d %H:%M:%S"    1 		#当前时间
    //"T"    ""                     1  		#制表（4空格）
    //"t"	 ""						1	    #线程ID
    //"T"    ""                     1 		#制表（4空格）
    //"F"    ""                     1		#协程ID
    //"T"    ""                     1 		#制表（4空格）
    //"["    ""                     0		#普通字符
    //"p"    ""                     1		#日志级别
    //"]"    ""                     0		#普通字符
    //"T"    ""                     1  		#制表（4空格）
    //"["    ""                     0		#普通字符
    //"c"    ""                     1		#日志器名称
    //"]"    ""                     0		#普通字符
    //"T"    ""                     1 		#制表（4空格）
    //"f"    ""                     1		#文件名称
    //":"    ""                     0		#普通字符
    //"l"    ""                     1		#行号
    //"T"    ""                     1 		#制表（4空格）
    //"m"    ""                     1		#消息
    //"n"    ""                     1 		#换行  

    //各个符号的具体解析
    class MessageFormatItem : public LogFormatter::FormatItem {
    public:
        MessageFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << "Message";
        }
    };

    class LevelFormatItem : public LogFormatter::FormatItem {
    public:
        LevelFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << LogLevel::ToString(level);
        }
    };

    class ElapseFormatItem : public LogFormatter::FormatItem {
    public:
        ElapseFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << event->getElapse();
        }
    };

    class NameFormatItem : public LogFormatter::FormatItem {
    public:
        NameFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << "Name";
        }
    };

    class ThreadIdFormatItem : public LogFormatter::FormatItem {
    public:
        ThreadIdFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << event->getThreadId();
        }
    };

    class FiberIdFormatItem : public LogFormatter::FormatItem {
    public:
        FiberIdFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << event->getFiberId();
        }
    };

    class DateTimeFormatItem : public LogFormatter::FormatItem {
    public:
        DateTimeFormatItem(const std::string& format = "%Y-%m-%d %H:%M:%S")
            :m_format(format) {
            if(m_format.empty()) {
                m_format = "%Y-%m-%d %H:%M:%S";
            }
        }

        void format(std::ostream& os, LogEvent::ptr event) override {
            struct tm tm;
            time_t time = event->getTime();
            localtime_r(&time, &tm);
            char buf[64];
            strftime(buf, sizeof(buf), m_format.c_str(), &tm);
            os << buf;
        }
    private:
        std::string m_format;
    };

    class FilenameFormatItem : public LogFormatter::FormatItem {
    public:
        FilenameFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << event->getFile();
        }
    };

    class LineFormatItem : public LogFormatter::FormatItem {
    public:
        LineFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << event->getLine();
        }
    };

    class NewLineFormatItem : public LogFormatter::FormatItem {
    public:
        NewLineFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << std::endl;
        }
    };

    class StringFormatItem : public LogFormatter::FormatItem {
    public:
        StringFormatItem(const std::string& str)
            :m_string(str) {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << m_string;
        }
    private:
        std::string m_string;
    };

    class TabFormatItem : public LogFormatter::FormatItem {
    public:
        TabFormatItem(const std::string& str = "") {}
        void format(std::ostream& os, LogEvent::ptr event) override {
            os << "\t";
        }
    private:
        std::string m_string;
    };
    //

    LogFormatter::init(){
        //我们粗略的把上面的解析对象分成两类 一类是普通字符串 另一类是可被解析的
        //可以用 tuple来定义 需要的格式 std::tuple<std::string,std::string,int> 
        //<符号,子串,类型>  类型0-普通字符串 类型1-可被解析的字符串 
        //可以用一个 vector来存储 std::vector<std::tuple<std::string,std::string,int> > vec;
        std::vector<std::tuple<std::string,std::string,int> > vec;
        //解析后的字符串
        std::string nstr;
        //循环中解析
        for(size_t i = 0; i < m_pattern.size(); ++i) {
            // 如果不是%号
            // nstr字符串后添加1个字符m_pattern[i]
            if(m_pattern[i] != '%') {
                nstr.append(1, m_pattern[i]);
                continue;
            }
            // m_pattern[i]是% && m_pattern[i + 1] == '%' ==> 两个%,第二个%当作普通字符
            if((i + 1) < m_pattern.size()) {
                if(m_pattern[i + 1] == '%') {
                    nstr.append(1, '%');
                    continue;
                }
            }
            
            // m_pattern[i]是% && m_pattern[i + 1] != '%', 需要进行解析
            size_t n = i + 1;		// 跳过'%',从'%'的下一个字符开始解析
            int fmt_status = 0;		// 是否解析大括号内的内容: 已经遇到'{',但是还没有遇到'}' 值为1
            size_t fmt_begin = 0;	// 大括号开始的位置

            std::string str;
            std::string fmt;	// 存放'{}'中间截取的字符
            // 从m_pattern[i+1]开始遍历
            while(n < m_pattern.size()) {
                // m_pattern[n]不是字母 & m_pattern[n]不是'{' & m_pattern[n]不是'}'
                if(!fmt_status && (!isalpha(m_pattern[n]) && m_pattern[n] != '{'
                        && m_pattern[n] != '}')) {
                    str = m_pattern.substr(i + 1, n - i - 1);
                    break;
                }
                if(fmt_status == 0) {
                    if(m_pattern[n] == '{') {
                        // 遇到'{',将前面的字符截取
                        str = m_pattern.substr(i + 1, n - i - 1);
                        //std::cout << "*" << str << std::endl;
                        fmt_status = 1; // 标志进入'{'
                        fmt_begin = n;	// 标志进入'{'的位置
                        ++n;
                        continue;
                    }
                } else if(fmt_status == 1) {
                    if(m_pattern[n] == '}') {
                        // 遇到'}',将和'{'之间的字符截存入fmt
                        fmt = m_pattern.substr(fmt_begin + 1, n - fmt_begin - 1);
                        //std::cout << "#" << fmt << std::endl;
                        fmt_status = 0;
                        ++n;
                        // 找完一组大括号就退出循环
                        break;
                    }
                }
                ++n;
                // 判断是否遍历结束
                if(n == m_pattern.size()) {
                    if(str.empty()) {
                        str = m_pattern.substr(i + 1);
                    }
                }
            }

            if(fmt_status == 0) {
                if(!nstr.empty()) {
                    // 保存其他字符 '['  ']'  ':'
                    vec.push_back(std::make_tuple(nstr, std::string(), 0));
                    nstr.clear();
                }
                // fmt:寻找到的格式
                vec.push_back(std::make_tuple(str, fmt, 1));
                // 调整i的位置继续向后遍历
                i = n - 1;
            } else if(fmt_status == 1) {
                // 没有找到与'{'相对应的'}' 所以解析报错，格式错误
                std::cout << "pattern parse error: " << m_pattern << " - " << m_pattern.substr(i) << std::endl;
                vec.push_back(std::make_tuple("<<pattern_error>>", fmt, 0));
            }
        }

        if(!nstr.empty()) {
            vec.push_back(std::make_tuple(nstr, "", 0));
        }
        
        static std::map<std::string, std::function<FormatItem::ptr(const std::string& str)> > s_format_items = {
            #define XX(str, C) \
                    {#str, [](const std::string& fmt) { return FormatItem::ptr(new C(fmt));}}

                    XX(m, MessageFormatItem),
                    XX(p, LevelFormatItem),
                    XX(r, ElapseFormatItem),
                    XX(c, NameFormatItem),
                    XX(t, ThreadIdFormatItem),
                    XX(n, NewLineFormatItem),
                    XX(d, DateTimeFormatItem),
                    XX(f, FilenameFormatItem),
                    XX(l, LineFormatItem),
                    XX(T, TabFormatItem),
                    XX(F, FiberIdFormatItem),
            #undef XX
                };

        for(auto& i : vec) {
            if(std::get<2>(i) == 0) {
                m_items.push_back(FormatItem::ptr(new StringFormatItem(std::get<0>(i))));
            } else {
                auto it = s_format_items.find(std::get<0>(i));
                if(it == s_format_items.end()) {
                    m_items.push_back(FormatItem::ptr(new StringFormatItem("<<error_format %" + std::get<0>(i) + ">>")));
                } else {
                    m_items.push_back(it->second(std::get<1>(i)));
                }
            }
        }   

    }
    std::string LogFormatter::format(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event) {
        std::stringstream ss;
        for(auto& i : m_items) {
            i->format(ss, logger, level, event);
        }
        return ss.str();
    }

    std::ostream& LogFormatter::format(std::ostream& ofs, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event) {
        for(auto& i : m_items) {
            i->format(ofs, logger, level, event);
        }
        return ofs;
    }

    int main(int argc,char** argv){
    //创建一个日志事件(这里的内容随便定义，因为我们没有真正用到它)
    LogEvent::ptr event(new LogEvent(
        LogLevel::INFO,     //日志级别
        __FILE__,           //文件名称
        __LINE__,           //行号
        1234567,            //运行时间
        syscall(SYS_gettid),//线程ID
        0,                  //协程ID
        time(0)             //当前时间
    ));

    LogFormatter::ptr formatter(new LogFormatter("%d{%Y-%m-%d %H:%M:%S}%T%t%T%F%T[%p]%T[%c]%T%f:%l%T%m%n"));
    std::cout << formatter->format(event);
    return 0;
    }
```
6. 在适配器中添加私有字段-格式器，并将日志器名称通过构造存放到`LogEvent`的私有字段且提供`get`方法。
```cpp
    //在适配器中添加私有字段 格式器
    class LogAppender {
    public:
        ...
        void setFormatter(LogFormatter::ptr val) { m_formatter = val;}
        LogFormatter::ptr getFormatter() const { return m_formatter;}
    protected:
        ...
        LogFormatter::ptr m_formatter;
    };

    //控制台输出器的方法
    void StdoutLogAppender::log(LogEvent::ptr event) {
        std::cout << m_formatter->format(event);
    }
    //文件输出器暂时不写（我们最后再做扩展）
    void FileLogAppender::log(LogEvent::ptr event) {
        ...
    }
    //修改LogEvent
    class LogEvent {
    public:
        ...
        LogEvent(const std::string& logName, LogLevel::Level level
            ,const char* file, int32_t m_line, uint32_t elapse
            , uint32_t thread_id, uint32_t fiber_id, uint64_t time);
        const std::string& getLogName() const { return m_logName;}
    private:
        ...
        std::string m_logName;
    };
    //修改NameFormatItem
    class NameFormatItem : public LogFormatter::FormatItem {
    public:
    NameFormatItem(const std::string &str = "") {}
    void format(std::ostream &os, LogEvent::ptr event) override {
        os << event->getLogName();
    }
    };
```
7. 传入Message信息，改造`LogEvent`增加字符流对象
```cpp
    class LogEvent {
    public:
        ...
        //此处增加流对象转字符串！！！
        std::string getContent() const { return m_ss.str(); } 
        //此处增加流对象get方法提供流式调用！！！
        std::stringstream& getSS() { return m_ss;}	
    private:
        ...
        //字符流【此处增加流对象！！！
        std::stringstream m_ss;       
    };
```
8. 提供流式输出，定义一个 LogEventWarp类进行RAII的方式调用输出。
```cpp
    class LogEventWrap {
    public:
        LogEventWrap(Logger::ptr logger, LogEvent::ptr e);
        ~LogEventWrap();
        LogEvent::ptr getEvent() const { return m_event; }
        std::stringstream &getSS();

    private:
        Logger::ptr m_logger;
        LogEvent::ptr m_event;
    };

    LogEventWrap::LogEventWrap(Logger::ptr logger, LogEvent::ptr e)
        : m_logger(logger), m_event(e) {
    }

    LogEventWrap::~LogEventWrap() { 
        m_logger->log( m_event); 
    }

    std::stringstream &LogEventWrap::getSS() { return m_event->getSS(); }
```
## 4.管理类实现
```cpp
    class LoggerManager {
    public:
        LoggerManager();
        Logger::ptr getLogger(const std::string& name);

        void init();
        Logger::ptr getRoot() const { return m_root;}
    private:
        std::map<std::string, Logger::ptr> m_loggers;
        Logger::ptr m_root;
    };

    typedef sylar::Singleton<LoggerManager> LoggerMgr;

    }

    LoggerManager::LoggerManager() {
        m_root.reset(new Logger);
        m_root->addAppender(LogAppender::ptr(new StdoutLogAppender));
    }

    Logger::ptr LoggerManager::getLogger(const std::string& name) {
        auto it = m_loggers.find(name);
        return it == m_loggers.end() ? m_root : it->second;
    }
```
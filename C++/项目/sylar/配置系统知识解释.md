# 配置系统知识解释
## 1.字符串与目标类型之间的转换
使用boost库中的`lexical_cast`函数实现转换。
```cpp
    #include "iostream"
    #include "boost/lexical_cast.hpp" // 需要包含的头文件
    
    int main(){
        char* p="32768";
        int i=0;
        // 将字符串转化为整数
        i=boost::lexical_cast<int>(p); 
        std::cout << i << std::endl;
        return i;
    }
```
## 2.find_first_not_of 与 find_last_not_of 的使用
1. `find_first_not_of()`函数：正向查找在原字符串中第一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回npos。（npos定义为保证大于任何有效下标的值。）
2. `find_last_not_of()`函数：正向查找在原字符串中最后一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回npos。（npos定义为保证大于任何有效下标的值。）
## 3.模板泛化，模板全特化，模板偏特化
1. 模板类的泛化、全特化、偏特化：
```cpp
    //1.泛化的Test类模板
    template<class T, class U>
    class Test	{
        Test(){cout << "泛化版本的构造函数" << endl;}
        void Func(){cout << "泛化版本" << endl;}
    };


    //2.全特化的Test类模板
    //当T和U这两个类型模板参数都为int类型时，做一个特化版本
    //全特化：就是所有类型模板参数(这里T 和 U),都用具体类型代表
    template<>	//全特化：所有类型模板参数都用具体类型代表，所以这里的template后面的<>里就为空
    class Test<int,int>	//上边的T绑定到这里的第一个int,上边的U绑定到这里的第二个int
    {
        Test(){cout << "int , int的特化版本构造函数" << endl;}
        //可以该特化版本进行单独处理
        void Func(){cout << "int , int的特化版本" << endl;}
    };

    //3.偏特化的类模板
    //从参数数量上进行偏特化，现在绑定两个类型模板参数
    template<typename U>	//留一个U类型模板参数
    class Test<int, U, double>{
        void Func() { cout << "偏特化int ,U, double版本" << endl; }
    };
```
2. 模板函数的泛化、全特化：
```cpp
    //泛化版本
    template<typename T, typename U>
    void Func(const T& a, const U& b){
        cout << "Func()泛化版本" << endl;
        cout << a << " " << b << endl;
    }
    //全特化版本
    template<>
    void Func(const int& a, const double& b){
        cout << "Func()int,double 全特化版本" << endl;
        cout << a << " " << b << endl;
    }
    //偏特化版本（不支持！！！）

    int main(){
        const char* p = "I Love China";
        int a = 12;
        Func(p, a);
        //全特化函数模板实际上等价于实例化一个函数模板，并不是等级一个函数重载
        Func(15, 25.3);	//特化版本
        return 0;
    }
```
3. 模板类作为函数返回对象时需要`typename`修饰
```cpp
    templete<class T>
    typename Test<T> func(){
        return new Test<T>();
    }
```
4. 模板类作为类型定义时需要`typename`修饰，`typename Test<T> t = new Test<T>();`
## 5.dynamic_pointer_cast
`std::dynamic_pointer_cast<目标类型>(被转换智能指针)`，接受一个被转换的智能指针和目标类型的指针类型作为参数，并返回一个新的智能指针。
dynamic_pointer_cast只适用于std::shared_ptr和std::weak_ptr类型的智能指针，用于进行智能指针的动态类型转换。
## 6.std::transform
它接受四个参数：
1. 输入范围的起始迭代器。
2. 输入范围的结束迭代器。
3. 输出范围的起始迭代器。
4. 一个一元操作函数，用于对输入范围内的每个元素进行处理。
```cpp
    std::vector<int> nums = {1, 2, 3, 4, 5};
    std::vector<int> result(nums.size());
    std::transform(nums.begin(), nums.end(), result.begin(), [](int x) { return x * 2; });

    //结合 ::tolower 
    std::string str="aBcDef";
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    std::cout << str << std::endl;	//abcdef
```
## 7.仿函数
仿函数是一个类或结构体，它重载了operator()运算符，使其可以像函数一样被调用。仿函数的实例可以像函数指针一样传递给STL算法或容器的操作，从而实现自定义行为。
```cpp
    template<class T>
    class Less {
    public:
        bool operator()(const T& x, const T& y){
            return x < y;
        }
    };
```
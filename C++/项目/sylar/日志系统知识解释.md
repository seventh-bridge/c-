# 日志系统知识解释
## 1.switch使用宏定义简化
目的：显示输出时可以看到对应的枚举字段。
```cpp
    const char* fruit2string(Fruit fruit){
        switch(fruit){
    //这是宏定义case块
    #define XX(name) 		\
        case fruit::name:	\
            return #name;	\		//注意 #name 是将对应的参数名称变成了字符串(这个是核心)
            break;
    //
            
            //宏定义是简单的文本替换 所以这里请不要加双引号，错误写法 XX("APPLE")
            XX(CHERRIES)
            XX(STRABERRY)
            XX(APPLE)
            XX(WATERMELON)
            
    #undef XX
            default:
                return "UNKNOW";
                break;
        }
        return "UNKNOW";	
    }
```
## 2.va_list 与 vasprintf 配合实现C风格的输出
目的：得到一个c风格格式化的字符串。
```cpp
    #include <sstream>
    #include <stdarg.h>
    //使用可变参数（由 ... 表示）来处理传入的多个参数
    std::string format(const char* fmt,...){
        std::stringstream ss;//std::stringstream 是一个流类，支持将数据写入到字符串中
        va_list args;//用于存储可变参数列表
        va_start(args,fmt);//宏初始化 args，让它指向传递给 format 函数的可变参数的第一个参数。fmt 是最后一个命名参数，因此它是 va_start 宏的第二个参数，表示可变参数的起始位置。
        char* buf = nullptr;
        int len = vasprintf(&buf,fmt,args);//用于根据格式字符串 fmt 和可变参数 args 生成格式化字符串，并将其存储在 buf 指向的内存中。vasprintf 会返回生成的字符串的长度，并将结果保存在 buf 中。
        if(len != -1){
            ss<<std::string(buf,len);
            free(buf);
        }
        va_end(args);
        return ss.str();
    }
```
## 3.巧用匿名对象析构函数进行流式输出
```cpp
//利用匿名对象的析构时机与具名对象不同，前者是执行完后立即析构，后者若在栈内，则超过作用域后析构，在推内，则手动释放时析构
    #include <iostream>
    #include <sstream>

    //日志对象
    class Logger {
    public:
        //构造
        Logger();	
        //析构
        ~Logger();	
        std::stringstream& getSS() { return m_ss; }
    private:
        std::stringstream m_ss;
    };
    Logger::Logger(){
        std::cout << "Logger()" << std::endl;
    }
    Logger::~Logger(){
        std::cout << m_ss.str() << std::endl;
        std::cout << "~Logger()" << std::endl;
    }

    int main(int argc,char** argv){
        std::cout << "===start===" << std::endl;
        Logger lg;
        lg.getSS() << "hello" << " " << "sylar";
        std::cout << "====end====" << std::endl;
        return 0;
    }
```
## 4.单例模板
```cpp
    #ifndef __SYLAR_SINGLETON_H_
    #define __SYLAR_SINGLETON_H_

    namespace sylar {

    //X 为了创造多个实例对应的Tag
    //N 同一个Tag创造多个实例索引
    template<class T, class X = void, int N = 0>
    class Singleton {
    public:
        static T* GetInstance() {
            static T v;
            return &v;
        }
    };

    //X 为了创造多个实例对应的Tag
    //N 同一个Tag创造多个实例索引
    template<class T, class X = void, int N = 0>
    class SingletonPtr {
    public:
        static std::shared_ptr<T> GetInstance() {
            static std::shared_ptr<T> v(new T);
            return v;
        }
    };

    }

    #endif
```
## 5.时间戳和人性化展示
```cpp
    int main(int argc,char** argv){
        const std::string m_format = "%Y-%m-%d %H:%M:%S";
        struct tm tm;
        time_t t = time(0);
        localtime_r(&t, &tm);
        char buf[64];
        strftime(buf, sizeof(buf), m_format.c_str(), &tm);
        std::cout << buf << std::endl;
        return 0;
    }
```
## 6.获取程序在系统中的线程ID
```cpp
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/syscall.h>

    int main(int argc,char** argv){
        std::cout << syscall(SYS_gettid) << std::endl;
        return 0;
    }
```
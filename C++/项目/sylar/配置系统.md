# 配置系统
## 1.概述
1. 用于定义/声明配置项，并且能从配置文件中加载用户配置。
2. 配置包含的要素：
    2.1 名称，唯一的字符串。
    2.2 类型
    2.3 值，有默认值
    2.4 配置变更通知
    2.5 校验方法
3. 具备的基本功能：
   3.1. 支持定义/声明配置项
   3.2. 支持更新配置项
   3.3. 支持从预置的途径中加载配置项
   3.4. 支持给配置项注册配置变更通知，一般通过注册回调函数来实现
   3.5. 支持给配置项设置校验方法
   3.6. 支持导出当前配置
## 2.模块设计
采用约定优于配置的思想，即所有配置项在定义时都带默认值，对配置名称大小不敏感，支持级别格式的数据类型，支持STL容器，支持自定义类型。
## 3.相关类
1. `ConfigVarBase`：配置项基类，纯虚类，定义了配置项公有的成员和方法，以及`toString/fromString`纯虚函数方法，用于和YAML字符串进行相互转换。
2. `ConfigVar`：具体的配置参数类，继承自`ConfigVarBase`，并且是一个模板类，有3个模板参数。第一个模板参数是类型T，表示配置项的类型。另外两个模板参数是`FromStr`和`ToStr`，这两个参数是仿函数，`FromStr`用于将`YAML`字符串转类型`T`，`ToStr`用于将`T`转`YAML`字符串。`ConfigVar`类在`ConfigVarBase`上基础上包含了一个`T`类型的成员和一个变更回调函数数组，此外，`ConfigVar`还提供了`setValue/getValue`方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数），以及`addListener/delListener`方法用于添加或删除配置变更回调函数。
3. `Config`: `ConfigVar`的管理类，负责托管全部的`ConfigVar`对象，单例模式。提供`Lookup`方法，用于根据配置名称查询配置项。如果调用`Lookup`查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。除此外，`Config`类还提供了`LoadFromYaml`和`LoadFromConfDir`两个方法，用于从`YAML`对象或从命令行-c选项指定的配置文件路径中加载配置。`Config`的全部成员变量和方法都是`static`类型，保证了全局只有一个实例。
## 4.类型转换
1. 基本类型转换：
```cpp
    /**
    * @brief 类型转换模板类(F 源类型, T 目标类型)
    */
    template <class F, class T>
    class LexicalCast {
    public:
        /**
        * @brief 类型转换
        * @param[in] v 源类型值
        * @return 返回v转换后的目标类型
        * @exception 当类型不可转换时抛出异常
        */
        T operator()(const F &v) {
            return boost::lexical_cast<T>(v);
        }
    };

    std::string str1 = LexicalCast<int, std::string>()(123);     // ok, str1等于"123"
    int int1 = LexicalCast<std::string, int>()("123");           // ok, int1等于123
    std::string str2 = LexicalCast<float, std::string>()(3.14);  // ok，str2等于"3.14"
    float float2 = LexicalCast<std::string, float>()("3.14");    // ok，float2等于3.14
```
2. 复杂类型转换：
```cpp
    /**
    * @brief 类型转换模板类片特化(YAML String 转换成 std::vector<T>)
    */
    template <class T>
    class LexicalCast<std::string, std::vector<T>> {
    public:
        std::vector<T> operator()(const std::string &v) {
            YAML::Node node = YAML::Load(v);
            typename std::vector<T> vec;
            std::stringstream ss;
            for (size_t i = 0; i < node.size(); ++i) {
                ss.str("");
                ss << node[i];
                vec.push_back(LexicalCast<std::string, T>()(ss.str()));
            }
            return vec;
        }
    };
    
    /**
    * @brief 类型转换模板类片特化(std::vector<T> 转换成 YAML String)
    */
    template <class T>
    class LexicalCast<std::vector<T>, std::string> {
    public:
        std::string operator()(const std::vector<T> &v) {
            YAML::Node node(YAML::NodeType::Sequence);
            for (auto &i : v) {
                node.push_back(YAML::Load(LexicalCast<T, std::string>()(i)));
            }
            std::stringstream ss;
            ss << node;
            return ss.str();
        }
    };
```
3. 自定义类型：
```cpp
    class Person{
    public:
        std::string m_name = "";
        int m_age = 0;
        bool m_sex = 0;

        std::string toString() const{
            std::stringstream ss;
            ss << "[Person name=" << m_name
            << "age=" << m_age
            << "sex=" << m_sex << "]";
            return ss.str();
        }
    };

    /**
    *数据类型转换-person偏特化版本
    * string -> person
    */
    template <>
    class LexicalCast<std::string, Person>{
    public:
        Person operator()(const std::string &v){
            // loads the input string as a single YAML document
            YAML::Node node = YAML::Load(v);
            Person p;
            p.m_name = node["name"].as<std::string>();
            p.m_age = node["age"].as<int>();
            p.m_sex = node["sex"].as<bool>();
            return p;
        }
    };

    /**
    * 数据类型转换-Person偏特化版本
    * Person -> string
    */
    template <>
    class LexicalCast<Person, std::string>{
    public:
        std::string operator()(const Person &v){
            YAML::Node node;
            node["name"] = v.m_name;
            node["age"] = v.m_age;
            node["sex"] = v.m_sex;
            std::stringstream ss;
            ss << node;
            return ss.str();
        }
    };
```
# C++标准库常见题型
## 1.list底层实现原理
答：list通常实现为一个带头节点的双向循环链表，每个节点包含一个数据域、一个前驱指针、一个后驱指针。
## 2.vector底层实现原理
答：vector是基于连续内存的动态数组实现，通常由三个指针维护。
1. _start：指向数组的首元素（即 begin()）。
2. _finish：指向最后一个元素的下一个位置（即 end()）。
3. _end_of_storage：指向当前分配内存的末尾（容量边界）。
## 3.vector内存增长机制
答：当触发扩容时，会分配一块更大的内存，一般是原容量的2倍，然后将旧内容移动拷贝过去，再将其销毁。
## 4.vector中reserve和resize的区别
答：共同点：容器内原有的元素不受影响，起到增加的作用，无视缩小操作；
不同点：reserve只能增加capacity，不会改变size；resize两者都会增加；reserve用来避免多次内存分配；resize确保操作符[]和at的安全性。
## 5.vector的元素类型为什么不能是引用
答：vector要求元素类型必须是可拷贝构造和可赋值的。而引用是不可拷贝和不可赋值，且在扩容时，引用无法满足在内存中连续存储，且能重新分配内存的要求。
## 6.STL容器如何解决线程安全问题
答：1.外部加锁保护容器安全。
2.使用第三方库提供内置线程安全容器，如Intel TBB。
3.无锁设计，线程使用独立容器，使用消息队列，采用生产者消费者模式传递消息。
4.结合智能指针实现安全共享。
## 7.deque底层实现原理
答：deque通常基于分段连续存储的复杂数据结构实现。一般由中控数组和数据块组成，前者是一个动态数组（指针数组），每个元素指向一个固定大小的数据块，后者存储元素。随机访问是计算元素数据库索引和偏移，再通过中控数组找到相应的数据块。头插和尾插都是在相应数据块插入，如果无空位，则分配新数据块并更新中控数组。扩容分中控数组扩容和数据块分配。
## 8.multiset底层实现原理，红黑树原理
答：multiset通常基于红黑树实现，因为红黑树天然支持有序存储，符合multiset维护元素顺序的需求，其次红黑树允许节点键值重复，增删改查操作高效，时间复杂度为logn，此外红黑树的插入和删除操作仅影响局部节点，其他元素的迭代器不会失效，而vector可能会触发扩容，导致迭代器失效。
## 9.priority_queue底层实现原理
答：priority_queue通常使用动态数组来隐式表示一个完全二叉树，并通过堆算法维护堆（默认最大堆）性质。
## 10.unordered_map底层实现原理，哈希表原理
答:unordered_map通常由散列表和桶数组组成，当发生哈希冲突时，会将冲突元素存储在同一个桶。当触发扩容机制时，会分配一个更大的桶数组，然后对旧桶中的所有键值对重新进行哈希计算。
## 11.迭代器有哪些种类
答：迭代器分为输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机迭代器。
## 12.迭代器失效？连续和非连续存储容器的失效
答：迭代器的有效性取决于容器的修改操作，例如容器为vector（连续）时，插入/删除、resize会导致迭代器失效；容器为unordered_map（非连续）时，	插入可能触发扩容导致全失效，删除仅当前失效。
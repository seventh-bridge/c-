# 索引
## 结构
1. 二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量的情况下，层级较深，检索速度慢。
2. 红黑树缺点：大数据量的情况下，层级较深，检索速度慢。
3. B-Tree缺点：
4. B+Tree：所有数据都会出现在叶子节点，叶子节点形成一个单向链表。
5. hash特点：只能用于对等比较，不支持范围查询；无法利用索引完成排序操作；查询效率高，通常只需要一次检索就可以，效率通常要高于B+Tree。
## 分类
1. 主键索引：针对于表中主键创建的索引；只能有一个；`primary`。
2. 唯一索引：避免同一个表中某数据列中的值重复；可以有多个；`unique`。
3. 常规索引：快速定位特定数据；可以有多个。
4. 全文索引：全文索引查找的是文本中的关键词，而不是比较索引中的值；可以有多个；`fulltext`。

根据索引的存储形式，可以分为：
1. 聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据；必须有且只有一个。
2. 二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键；可以存在多个。

聚集索引选取规则:
1. 如果存在主键，主键索引就是聚集索引。
2. 如果不存在主键，将使用第一个唯一索引作为聚集索引。
3. 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

## 语法
1. 创建索引：`create [unique|fulltext] index index_name on table_name(index_col_name,...);`
2. 查看索引：`show index from table_name;`
3. 删除索引：`drop index index_name on table_name;`

## 使用规则
1. 最左前缀法则：对于联合索引来说，最左索引必须存在，且不能跳过中间索引，否则索引会失效。
2. 若对索引使用函数运算则索引会失效。
3. 若索引检索使用了范围(>,<)，则该索引右侧会失效。
4. 若发生了隐式数据类型转换，则索引会失效。
5. 模糊查询：若仅仅是尾部模糊查询，索引不会失效，但头部模糊匹配，索引失效。
6. 用or分割开的条件，若or前面条件中的列有索引，后面的列没有索引，则所涉及到的索引都不会使用。
7. 若mysql评估全表查询比索引查询快，则不会使用索引查询。

## SQL提示
在SQL语句中加入一些人为的提示来优化索引查询。
1. 建议使用某索引：`select * from tb_user use index(idx_user_pro) where profession='软件工程';`
2. 忽略某索引：`select * from tb_user ignore index(idx_user_pro) where profession='软件工程';`
3. 必须使用某索引：`select * from tb_user force index(idx_user_pro) where profession='软件工程';`

## 索引使用
1. 覆盖索引：不需要回表查询
2. 前缀索引：将字符串的一部分前缀建立索引`create index idx_xxx on table_name(column(n));`
3. 单列索引：一个索引只包含单个列
4. 联合索引：一个索引包含了多个列